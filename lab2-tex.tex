%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{enumitem}% For lists
\usepackage{mathptmx}% For textbf
\usepackage{float} %for correct image placement
\usepackage{textcomp} % for texttildelow
\usepackage[T1]{fontenc} % allows use of less than <


\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{M152A - Lab 2 \\ Floating Point Conversion} % Title

\author{Markus \textsc{Notti} - 904269231 \\ Kyle \textsc{Baker}  - 604273748 \\ Niels \textsc{Pineda} - 604272353} % Author name


\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section*{Introduction}

We began by implementing the project given using the provided FPGA Design and Implementation Fundamentals pdf.  This pdf showed us both the step by step implementation in ISE and a conceptual overview of the FPGA design principles.  

\begin{enumerate}[label=\alph*]

\item \textbf{Design:} This is not actually performed within the Xilinx ISE.  The design is used to map out logical schematics in order to give a clear idea of the high level functionality of the module. 

\item \textbf{Implementation:} After designing the overall logic of the program and figuring out certain modules? dependencies as well as their contents, this is where the actual code is written to implement the program.  For this lab, the code was already written, and the hierarchy was clearly presented in the ISE.  The overarching file was tb.v, the test bench file, followed by a uut (unit under test) named nexys3.v.  Following the uut, are the sequencer, seq.v, which consists of the ALU and register files, and uart (uart\_top.c), which consists of the interface.

\item \textbf{Simulation:} For simulating the program, ISE provides the tool ISIM which simulates the behavior of the program designed before actually having to load the code to the FPGA.  Our simulation was for the the test bench file (tb.v), and we had to add specific signals to the waveform display (we used inst\_wd and inst\_vld).  After running the simulation, the output was what we expected. 

\item \textbf{Logic Synthesis:} In this stage, ISE uses XST to synthesize the project, essentially creating a mapping of the logic gates which will need to be used by the FPGA to actually implement the program.  The synthesis file we used was nexys3.ucf.

\item \textbf{Technology Mapping:} In this stage of development, NGDBUILD in the ISE webpack is used to actually map the synthesized program to the FPGA.
Cell Placement: In this stage, ISE uses MAP in the ISE webpack to map specific cells in the netlist to specific locations on the physical FPGA device

\item \textbf{Route:} PAR, another tool in the ISE webpack is used to determine how to connect the cells on the physical device.

\item \textbf{Bitstream Generation: } Finally, after the cells are mapped and connected in a way suited for the physical device, a bitstream file (nexys3.bit)  is generated by the ISE webpack.  This ?.bit? file is then loaded to the physical device, and the FPGA board now can run the program on its own.


\end{enumerate}

 
%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section*{Exercise 2 - Translate the Program}

\begin{center}
\begin{tabular}{ c c}

 \textbf{Binary} & \textbf{Sequencer Instruction} \\ 
 0000 0100 & PUSH R0 0x4 \\  
 0000 0000 & PUSH R0 0x0 \\
0001 0011 & PUSH R1 0x3 \\
1000 0110 & MULT R0 R1 R2 \\
0110 0011 & ADD R2 R0 R3 \\
1100 0000 & SEND R0 \\
1101 0000 & SEND R1 \\
1110 0000 & SEND R2 \\
1111 0000 & SEND R3 \\
 
\end{tabular}
\end{center}

This leads to the console output (via putty):

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8\textwidth]{image02.jpg} % Include the image placeholder.png
\caption{Putty console output from instructions above in exercise 2.}
\end{center}
\end{figure}


%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------

\section*{Exercise 3 - Fibonacci}

The  ``program'' (instructions) for the Fibonacci Sequence was stored in a .txt file and read into ISE within the test bench file (using \$readmemb).  The Fibonacci program along with translation:

\begin{center}
\begin{tabular}{ c c}

 \textbf{Binary} & \textbf{Sequencer Instruction} \\ 
	0000 0000 & PUSH R0 0x0 \\	
	0001 0001 & PUSH R1 0x1 \\
	1100 0000	 & SEND R0 \\
	1101 0000	 & SEND R1 \\
	0100 0100 & ADD R0 R1 R0 \\
	1100 0000	 & SEND R0 \\
	01000101	& ADD R0 R1 R1 \\
	11010001	& SEND R1 \\
	01000100	& ADD R0 R1 R0 \\
	11000000	& SEND R0 \\
	01000101	& ADD R0 R1 R1 \\
	11010001	& SEND R1 \\
	01000100	& ADD R0 R1 R0 \\
	11000000	& SEND R0 \\
	01000101	& ADD R0 R1 R1 \\
	11010001	& SEND R1 \\
	01000100	& ADD R0 R1 R0 \\
	11000000	& SEND R0 \\
	01000101	& ADD R0 R1 R1 \\
	11010001	& SEND R1 \\
	01000100	& ADD R0 R1 R0 \\

 
\end{tabular}
\end{center}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8\textwidth]{image04.png} 
\caption{Putty console output from Fibonacci Program instructions, above in exercise 3.}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8\textwidth]{image09.jpg} 
\caption{ISIM UART output from Fibonacci Program instructions, above in exercise 3.}
\end{center}
\end{figure}

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------

\section*{Exercise 4 - Clock Enable, Instruction Valid and Register File}
\subsection*{Clock Enable}

 \begin{enumerate}[label=\arabic*),ref=\arabic*]
   \item clk\_en is a clock enable signal whose value allows (or does not allow) for the modification of the other signals: step\_d and inst\_wd.  In other words, clk\_en enables the clock which allows for the execution of instructions.
   \item clk\_en added to the waveform in the simulation.  \textbf{clk\_en`s period = 1.3107ms}
   
   \begin{figure}[H]
   \begin{center}
\includegraphics[width=0.8\textwidth]{image01.png} 
\caption{Waveform showing period of clk\_en}
\end{center}
\end{figure}

\item When clk\_en is high (1), clk\_dv, which is 16 bits, has a value of 0 (0000000000000000).

\item Circuit Diagram:
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8\textwidth]{image07.png} 
\caption{Circuit diagram illustrating relationship between clk\_en, clk\_dv, and clk\_en\_d}
\end{center}
\end{figure}
  \end{enumerate}

\subsection*{Instruction Valid}
 \begin{enumerate}[label=\arabic*),ref=\arabic*]
 	\item Now move on to the signal inst\_vld. Read the relevant code and use the simulation as your aid, answer the following questions in your lab report.
	\item In the simulation, the first time interval in which inst\_vld = \texttildelow step\_d[0] \& step\_d[1] \& clk\_en\_d evaluates to 1 is at \textbf{5.24395 ms}. 
	\item Clk\_en\_d introduces a one clock cycle delay, so it is used instead of clk\_en so instruction execution occurs a clock cycle later.  
	\item Another waveform capture:
	\begin{figure}[H]
	\begin{center}
	\includegraphics[width=1\textwidth]{image10.jpg} 
	\caption{A waveform capture that clearly shows the timing relationship between clk\_en, step\_d[1], step\_d[0], btnS, clk\_en\_d, and inst\_vld.}
	\end{center}
	\end{figure}
	
	\item Supporting Circuit Diagram:
	\begin{figure}[H]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{image08.jpg} 
	\caption{Circuit Diagram for the above relationship illustrated by the waveform in the previous figure}
	\end{center}
	\end{figure}
	
	
\end{enumerate}

\subsection*{Register File}
\begin{enumerate}[label=\arabic*), ref=\arabic*]
	\item The sequencer?s register file is located in a file called seq\_rf.v. It stores the values of the four registers. Take a look at the source code and see if you can understand how it is implemented. Answer the following questions in the lab report.
	\item The first line of code where a register is written a non-zero value is: 
		\begin{center}
		rf[i\_wsel] <= i\_wdata; 
		\end{center}
This is located in an always block, so we know this is sequential logic.  Additionally, 
the code utilizes <= (non-blocking assignment operator) which are used in sequential circuits. 
	\item The lines of code where the register values are read out from the register file are 
\begin{center}
assign o\_data\_a = rf[i\_sel\_a]; \\
assign o\_data\_b = rf[i\_sel\_b];
\end{center}
These use combinatorial logic as they use the = (blocking assignment) which are used in combinatorial circuits.  Additionally, it is not located in an always block.  If we were to manually implement this readout logic, we would use a multiplexer that uses a 2-bit value. 

	\item Circuit Diagram:
	\begin{figure}[H]
	\begin{center}
	\includegraphics[width=1\textwidth]{image03.jpg} 
	\caption{Register block circuit diagram}
	\end{center}
	\end{figure}
	
The above diagram begins with a demux which represents the if (rst) statement. If rst is 1, D1 will receive a signal of 1. This leads to a series of 4 muxes where the high signal will be fed in as the select of each mux. That signal is also fed into a not gate, which is then fed to each of the muxes so that they all have input 0. This makes each of the rf flip flops get the value 0, which is what happens in the code at this point if rst is true. If rst is not true, then D0 will get the high signal, which will be fed into another demux as input. The select for this demux will be i\_wstb, which represents the else if (i\_wstb) in the code. If i\_wstb is true, S1 will get a high signal and input to a channel with one demux and four muxes. The purpose of this channel is to imitate the line rf[i\_wsel] <= i\_wdata; by feeding a high signal to the multiplexer that connects to the rf correctly indexed by i\_wsel. This multiplexer will then feed i\_wdata into a multiplexer, which will have a select value that is 0 because rst was 0. The value of i\_wdata will eventually go into the intended rf flip flop. The rf boxes work similar to the component in the diagram in number 5 of the``Input Valid'' section, where the flip flops only change their values on certain inputs. The flip flops then send their data to two multiplexers with select values as i\_sel\_a and i\_sel\_b to emulate the assignments assign o\_data\_a = rf[i\_sel\_a]; and assign o\_data\_b = rf[i\_sel\_b]; to feed to the outputs.

\item The first time register 3 is written with a non-zero value is at \textbf{23.594ms}. 
	\begin{figure}[H]
	\begin{center}
	\includegraphics[width=1\textwidth]{image00.jpg} 
	\caption{Waveform showing first time register 3 is written with a non-zero value}
	\end{center}
	\end{figure}


	

\end{enumerate}


%----------------------------------------------------------------------------------------
%	SECTION 5
%----------------------------------------------------------------------------------------

\section*{Exercise 5 -Nicer UART Output}

\begin{enumerate}[label=\arabic*), ref=\arabic*]
\item Below is the code taken from tb.v which sends the instructions to the UUT. It takes an 8 bit instruction as input and outputs those same 8 bits as `sw` to the UUT : 
\begin{center}

task tskRunInst; \\
      input [7:0] inst; \\
begin \\
\$display (``\%d ... Running instruction \%08b'', \$stime, inst); \\
 sw = inst; \\
\#1500000 btnS = 1; \\
\#3000000 btnS = 0; \\
end \\
endtask
\end{center}
\item In this process, tskRunInst is the final task which outputs the instruction to the UUT,  and it is called by several other tasks: tskRunPUSH, tskRunSEND, tskRunADD, and tskRunMULT, each of which are responsible for running a unique instruction.
  
Nice uART output: rather than having it output byte by byte that is received, as seen in the Fibonacci sequence section above, it outputs all 4 bytes received.  The following is a screenshot of the cleaner output:

	\begin{figure}[H]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{image05.png} 
	\caption{Cleaner UART output}
	\end{center}
	\end{figure}



\end{enumerate}

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

%\bibliographystyle{apalike}

%\bibliography{sample}

%----------------------------------------------------------------------------------------


\end{document}